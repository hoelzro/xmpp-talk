\part{Writing an XMPP Bot with AnyEvent::XMPP}

\newpage
Now we're going to go through how you would develop an XMPP bot
using AnyEvent::XMPP.  We'll start simple, but by the time we're
finished, we'll have ourselves a bot capable of handling both one-on-one
and multiuser conversations.

\pause
So, without further ado, here is iteration 1 of the bot:

\pause

\begin{shaded}
\inputminted{perl}{examples/bare-bot.pl}
\end{shaded}

\pause

Now that we've got some code, let's walk through the example...

\newpage

\begin{shaded}
\begin{minted}{perl}
#!/usr/bin/env perl

# comments...

use strict;
use warnings;
\end{minted}
\end{shaded}

\pause
\begin{comment}
You should be familiar with this part already!
\end{comment}

\begin{shaded}
\begin{minted}{perl}
use AnyEvent::XMPP::IM::Connection;
\end{minted}
\end{shaded}

\pause
\begin{comment}
This statement loads the AnyEvent::XMPP::IM::Connection class.  Normally I wouldn't
waste my time explaining a use statement, but I just want to make sure you know there
are three connection classes in AnyEvent::XMPP:

\begin{description}
\item[AnyEvent::XMPP::Connection] Simple connections; no bells and whistles.
\item[AnyEvent::XMPP::IM::Connection] Provides more advanced events (message, contact_request_subscribe), initial presence, roster.
\item[AnyEvent::XMPP::Client] Manages multiple connections.
\end{description}
\end{comment}

\begin{shaded}
\begin{minted}{perl}
my $cond = AnyEvent->condvar;

# some code in the middle...

$cond->recv;
\end{minted}
\end{shaded}

\begin{comment}
This is how you run an AnyEvent event loop.  If you're not familiar with AnyEvent, I suggest you read up on it; however, intimate knowledge of it is not necessary for this tutorial.
\end{comment}

\newpage
\begin{shaded}
\begin{minted}{perl}
my $conn = AnyEvent::XMPP::IM::Connection->new(
    jid      => 'rob@localhost',
    password => 'abc123',
);

$conn->connect;
\end{minted}
\end{shaded}

\begin{comment}
Creates a connection object and connects when the event loop starts running.
Authenticates as rob@localhost, using the password 'abc123'.
\end{comment}

\newpage
Now, that example doesn't really do much useful.  It remains silent on failure
\footnote{Actually, a bug in AnyEvent::XMPP causes the program to warn on
authentication failure.}, and no matter the outcome, the program still hangs.
What we need is a program that exits after logging in (or failing to log in),
and that reports errors.  Revision 2 of the example does just that:

\newpage
\begin{shaded}
\inputminted{perl}{examples/simple-bot.pl}
\end{shaded}

\newpage
Let's go through the new pieces of code:

\pause
\begin{shaded}
\begin{minted}{perl}
use feature 'say';
\end{minted}
\end{shaded}

\begin{comment}
This pragma brings in the 'say' function, which is basically print
with a newline.  If you're not using Perl 5.10 later by now, I highly
suggest you do; 5.10 and 5.12 are full of great new features!
\end{comment}

\pause
\begin{shaded}
\begin{minted}{perl}
$conn->reg_cb(session_ready => sub {
    say "Successfully connected!";
    $cond->send;
});
\end{minted}
\end{shaded}

\begin{comment}
This example connects to the session\_ready signal, which is
fired when the connection is fully established.  \$cond->send is
the code we use to terminate the event loop.
\end{comment}

\pause
\begin{shaded}
\begin{minted}{perl}
$conn->reg_cb(error => sub {
    my ( undef, $error ) = @_;

    say "Uh-oh: " . $error->string;
    $cond->send;
});
\end{minted}
\end{shaded}

\begin{comment}
This chunk is similar to the previous, but we're connecting to the
error signal.  We ignore the first argument passed to the handler
(which is the connection object), and grab the error object to print
it out.
\end{comment}
